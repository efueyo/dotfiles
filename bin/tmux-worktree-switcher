#!/usr/bin/env bash

# Tmux worktree switcher - switch between git worktrees in tmux sessions

set -e

# Delete worktree handler (called by fzf keybinding)
delete_worktree_handler() {
    local bare_repo=$1
    local repo_name=$2
    local worktree_name=$3

    # Don't allow deleting [CREATE NEW]
    if [[ "$worktree_name" == "[CREATE NEW]" ]]; then
        echo "Cannot delete [CREATE NEW]" >&2
        read -p "Press Enter to continue..."
        return 1
    fi

    # Confirm deletion
    local confirm
    confirm=$(echo -e "Yes\nNo" | fzf --prompt="Delete worktree '$worktree_name'? " || true)

    if [[ "$confirm" != "Yes" ]]; then
        return 1
    fi

    local worktree_path="$bare_repo/trees/$worktree_name"

    # Remove the worktree
    if git -C "$bare_repo" worktree remove "$worktree_path" 2>/dev/null; then
        echo "Deleted worktree '$worktree_name'" >&2

        # Kill associated tmux session if it exists
        local session_name="${repo_name}_${worktree_name}"
        session_name=$(echo "$session_name" | tr .-/ _)

        if tmux has-session -t="$session_name" 2>/dev/null; then
            tmux kill-session -t "$session_name"
            echo "Killed tmux session '$session_name'" >&2
        fi
    else
        echo "Failed to delete worktree '$worktree_name'" >&2
    fi

    read -p "Press Enter to continue..."
    return 0
}

# Find the bare repo root from current worktree
find_bare_repo() {
    local current_dir
    current_dir=$(git rev-parse --show-toplevel 2>/dev/null || echo "")

    if [[ -z "$current_dir" ]]; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi

    # Check if we're in a worktree structure (e.g., ~/repos/MY_REPO/trees/branch)
    # Navigate up to find the bare repo
    if [[ "$current_dir" =~ (.+)/trees/[^/]+$ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        # Might be in the bare repo itself or non-worktree structure
        # Try to find the common dir
        local git_common_dir
        git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
        if [[ "$git_common_dir" =~ (.+)/worktrees/.+ ]]; then
            echo "${BASH_REMATCH[1]}"
        else
            echo "$current_dir"
        fi
    fi
}

# Get current branch
get_current_branch() {
    git branch --show-current
}

# List worktrees and let user select or create new
select_worktree() {
    local bare_repo=$1
    local repo_name
    repo_name=$(basename "$bare_repo")

    cd "$bare_repo"

    # Get list of worktrees, extract just the branch/worktree names
    local worktrees
    worktrees=$(git worktree list | awk '{print $1}' | while read -r path; do
        basename "$path"
    done | grep -v "^$(basename "$bare_repo")$" || true)

    # Prepare fzf list with CREATE NEW option
    local fzf_input
    fzf_input=$(echo -e "[CREATE NEW]\n$worktrees")

    # Use fzf with --print-query to capture user input, with Ctrl-D for deletion
    local result
    result=$(echo "$fzf_input" | fzf \
        --print-query \
        --prompt="Select worktree for $repo_name: " \
        --bind "ctrl-d:execute($0 --delete '$bare_repo' '$repo_name' {})+abort" \
        || true)

    if [[ -z "$result" ]]; then
        exit 0
    fi

    # Parse fzf output: first line is query, second line is selection (if any)
    local query
    local selection
    query=$(echo "$result" | head -n1)
    selection=$(echo "$result" | sed -n '2p')  # Get 2nd line if it exists, empty otherwise

    echo "$query|$selection"
}

# Create new worktree
create_worktree() {
    local bare_repo=$1
    local worktree_name=$2
    local current_branch=$3

    cd "$bare_repo"

    # Confirm with fzf
    local confirm
    confirm=$(echo -e "Yes\nNo" | fzf --prompt="Create worktree '$worktree_name' from '$current_branch'? " || echo "No")

    if [[ "$confirm" != "Yes" ]]; then
        exit 0
    fi

    # Create the worktree (redirect git output to stderr so only path is returned)
    local worktree_path="$bare_repo/trees/$worktree_name"
    git worktree add "$worktree_path" -b "$worktree_name" >&2

    echo "$worktree_path"
}

# Main logic
main() {
    local bare_repo
    bare_repo=$(find_bare_repo)

    local current_branch
    current_branch=$(get_current_branch)

    local repo_name
    repo_name=$(basename "$bare_repo")

    # Get user selection
    local result
    result=$(select_worktree "$bare_repo")

    local query
    local selection
    query=$(echo "$result" | cut -d'|' -f1)
    selection=$(echo "$result" | cut -d'|' -f2)

    # Exit if both selection and query are empty (user cancelled without typing)
    if [[ -z "$selection" && -z "$query" ]]; then
        exit 0
    fi

    # If selection is empty but query is not, treat it as wanting to create new branch
    if [[ -z "$selection" && -n "$query" ]]; then
        selection="[CREATE NEW]"
    fi

    local worktree_name
    local worktree_path

    # Determine if we need to create a new worktree
    if [[ "$selection" == "[CREATE NEW]" ]]; then
        worktree_name="$query"

        # If query is empty, prompt for branch name
        if [[ -z "$worktree_name" ]]; then
            worktree_name=$(echo "" | fzf --print-query --prompt="Enter new branch name: " | tail -n1 || true)
            if [[ -z "$worktree_name" ]]; then
                exit 0
            fi
        fi

        # Create the new worktree (includes confirmation)
        worktree_path=$(create_worktree "$bare_repo" "$worktree_name" "$current_branch")

        # Exit if creation was cancelled
        if [[ -z "$worktree_path" ]]; then
            exit 0
        fi
    else
        # User selected or typed something that's not [CREATE NEW]
        worktree_name="$selection"

        # Check if this worktree actually exists
        if git -C "$bare_repo" worktree list | grep -q "/trees/$worktree_name "; then
            # Worktree exists, use it
            worktree_path="$bare_repo/trees/$worktree_name"
        else
            # Worktree doesn't exist, need to create it (includes confirmation)
            worktree_path=$(create_worktree "$bare_repo" "$worktree_name" "$current_branch")

            # Exit if creation was cancelled
            if [[ -z "$worktree_path" ]]; then
                exit 0
            fi
        fi
    fi

    # Session management (inspired by tmux-sessionizer)
    local session_name="${repo_name}_${worktree_name}"
    # Sanitize session name (tmux doesn't like certain characters)
    session_name=$(echo "$session_name" | tr .-/ _)

    # Check if session exists
    if ! tmux has-session -t="$session_name" 2>/dev/null; then
        # Create new session
        tmux new-session -ds "$session_name" -c "$worktree_path"
        # Select first window
        tmux select-window -t "$session_name:1"
    fi

    # Switch to session
    tmux switch-client -t "$session_name"
}

# Handle command-line arguments
if [[ "$1" == "--delete" ]]; then
    # Delete mode: called by fzf keybinding
    set +e  # Don't exit on errors in delete mode
    delete_worktree_handler "$2" "$3" "$4"
    exit 0
else
    # Normal mode: interactive selection
    main
fi
